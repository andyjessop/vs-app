{"version":3,"file":"app.js","sources":["../../utils/dist/utils.mjs","../../router/dist/router.mjs","../../di/dist/di.mjs"],"sourcesContent":["function createEventEmitter() {\n  const listeners = [];\n  return {\n    addListener,\n    emit,\n    removeListener,\n  };\n  function addListener(type, handler) {\n    const listener = { handler, type };\n    listeners.push(listener);\n  }\n  function emit(type, data) {\n    let listener;\n    for (listener of listeners) {\n      if (listener.type !== type) {\n        continue;\n      }\n      listener.handler(data);\n    }\n  }\n  function removeListener(type, handler) {\n    const ndx = listeners.findIndex((l) => type === l.type && handler === l.handler);\n    if (ndx !== -1) {\n      listeners.splice(ndx, 1);\n    }\n  }\n}\n\nfunction createAsyncQueue() {\n  const entries = [];\n  let flushing = false;\n  return {\n    add,\n    clear,\n    flush,\n  };\n  function add(fn, ...params) {\n    let rej = () => {};\n    let res = () => {};\n    const promise = new Promise((resolve, reject) => {\n      res = resolve;\n      rej = reject;\n    });\n    entries.push({\n      fn,\n      params,\n      reject: rej,\n      resolve: res,\n    });\n    return promise;\n  }\n  function clear() {\n    flushing = false;\n    entries.length = 0;\n  }\n  async function flush() {\n    if (flushing) {\n      return;\n    }\n    const entry = entries[0];\n    if (!entry) {\n      flushing = false;\n      return;\n    }\n    flushing = true;\n    try {\n      const result = await entry.fn(...entry.params);\n      entry.resolve(result);\n      entries.shift();\n      if (entries.length === 0) {\n        flushing = false;\n      }\n      return flush();\n    } catch (e) {\n      entry.reject(e);\n    }\n  }\n}\n\nfunction createSyncQueue() {\n  const entries = [];\n  let flushing = false;\n  return {\n    add,\n    flush,\n  };\n  function add(fn, ...params) {\n    entries.push({\n      fn,\n      params,\n    });\n  }\n  function flush() {\n    if (flushing) {\n      return;\n    }\n    const entry = entries.shift();\n    if (!entry) {\n      flushing = false;\n      return;\n    }\n    flushing = true;\n    entry.fn(...entry.params);\n    if (entries.length) {\n      return flush();\n    }\n  }\n}\n\nexport { createAsyncQueue, createEventEmitter, createSyncQueue };\n//# sourceMappingURL=utils.mjs.map\n","var Router;\n(function (Router) {\n  let Events;\n  (function (Events) {\n    Events['Transition'] = 'transition';\n  })((Events = Router.Events || (Router.Events = {})));\n})(Router || (Router = {}));\n\nfunction createEventEmitter() {\n  const listeners = [];\n  return {\n    addListener,\n    emit,\n    removeListener,\n  };\n  function addListener(type, handler) {\n    const listener = { handler, type };\n    listeners.push(listener);\n  }\n  function emit(type, data) {\n    let listener;\n    for (listener of listeners) {\n      if (listener.type !== type) {\n        continue;\n      }\n      listener.handler(data);\n    }\n  }\n  function removeListener(type, handler) {\n    const ndx = listeners.findIndex((l) => type === l.type && handler === l.handler);\n    if (ndx !== -1) {\n      listeners.splice(ndx, 1);\n    }\n  }\n}\n\nconst namedParamRegex = /:\\w[\\w\\d_]*(<[^>]+>)?/g;\n\nfunction escapeRegexes(pattern) {\n  const match = pattern.match(namedParamRegex) || [];\n  for (let i = 0; i < match.length; i++) {\n    const m = match[i];\n    const regex = m.slice(m.indexOf('<') + 1, m.length - 1);\n    pattern = pattern.replace(regex, encodeURIComponent(regex));\n  }\n  return pattern;\n}\n\nfunction getHash(path) {\n  return decodeURIComponent(path.replace(/^#/, ''));\n}\n\nfunction parseSegment(seg) {\n  if (seg[0] === ':') {\n    let regex = null;\n    const ndx = seg.indexOf('<');\n    let name = seg.slice(1, seg.length);\n    if (ndx >= 0) {\n      if (seg[seg.length - 1] !== '>') {\n        throw new Error('No closing >');\n      }\n      const regexStr = seg.slice(ndx + 1, seg.length - 1);\n      regex = new RegExp(`^(${regexStr})$`);\n      name = seg.slice(1, ndx);\n    }\n    return function curriedParseSegment(str, paths, array = false) {\n      if (array) {\n        paths[name] = [].concat(paths[name] || [], str);\n      } else {\n        paths[name] = str;\n      }\n      return !(regex && !regex.test(str));\n    };\n  } else {\n    return function curriedParseSegment(str) {\n      return str === seg;\n    };\n  }\n}\n\nfunction parsePaths(targets) {\n  const parsers = targets.map(parseSegment);\n  return function curriedParsePaths(path, params) {\n    if (targets.length !== path.length) {\n      return false;\n    }\n    for (let i = 0; i < targets.length; i++) {\n      if (!parsers[i](path[i], params)) {\n        return false;\n      }\n    }\n    return true;\n  };\n}\n\nfunction isList(p) {\n  return p.endsWith('*');\n}\n\nfunction isOptional(p) {\n  return p.endsWith('?');\n}\n\nfunction paramName(n) {\n  if (isOptional(n) || isList(n)) {\n    return n.slice(0, -1);\n  }\n  return n;\n}\n\nfunction parseQueries(target) {\n  const keys = Array.from(target.keys());\n  const parsers = keys.map((key) => parseSegment(target.get(key)));\n  return function curriedParseQueries(query, params) {\n    const queryKeys = Array.from(query.keys());\n    if (!keys.every((x) => isOptional(x) || isList(x) || queryKeys.includes(x))) {\n      return false;\n    }\n    for (let i = 0; i < keys.length; i++) {\n      const key = paramName(keys[i]);\n      if (isList(keys[i])) {\n        Array.from(query.entries())\n          .filter((x) => x[0] === key)\n          .forEach((x) => parsers[i](x[1], params, true));\n      } else if (!parsers[i](query.get(key), params) && !isOptional(keys[i])) {\n        return false;\n      }\n    }\n    return true;\n  };\n}\n\nfunction pathToURL(url) {\n  return new URL(`ftp://x/${url}`);\n}\n\nfunction trimSlashes(p) {\n  return p.replace(/(\\/$)|(^\\/)/g, '');\n}\n\nfunction splitPath(path) {\n  return trimSlashes(path).split('/').map(decodeURIComponent);\n}\n\nfunction parse(pattern) {\n  if (pattern[0] !== '/') {\n    throw new Error('Must start with /');\n  }\n  const target = pathToURL(escapeRegexes(trimSlashes(pattern)));\n  const targetSegments = splitPath(trimSlashes(target.pathname));\n  const targetHash = getHash(target.hash);\n  const pq = parseQueries(target.searchParams);\n  const pp = parsePaths(targetSegments);\n  const ph = parseSegment(targetHash);\n  return function decodeURL(urlString) {\n    const route = new URL(urlString);\n    const params = {};\n    if (\n      pp(splitPath(trimSlashes(route.pathname)), params) &&\n      pq(route.searchParams, params) &&\n      ph(getHash(route.hash), params)\n    ) {\n      return params;\n    }\n    return null;\n  };\n}\n\nfunction reverseSegment(str, dict) {\n  const match = str.match(namedParamRegex) || [];\n  for (let i = 0; i < match.length; i++) {\n    const m = match[i];\n    const endIx = m.indexOf('<');\n    let name = m.slice(1, endIx < 0 ? m.length : endIx);\n    if (isOptional(name) || isList(name)) {\n      name = name.slice(0, -1);\n    }\n    if (!(name in dict)) {\n      throw new Error(`${name} ${undefined}`);\n    }\n    str = str.replace(m, dict[name]);\n  }\n  return str;\n}\n\nfunction reverse(pattern) {\n  const escapedString = escapeRegexes(trimSlashes(pattern));\n  const target = pathToURL(escapedString);\n  const segments = splitPath(target.pathname);\n  return function encodeURL(dict) {\n    const result = pathToURL('');\n    result.pathname = segments.map((x) => reverseSegment(x, dict)).join('/');\n    target.searchParams.forEach((regex, n) => {\n      const name = paramName(n);\n      if (isList(n)) {\n        []\n          .concat(dict[name])\n          .filter(Boolean)\n          .forEach((x) => {\n            result.searchParams.append(name, reverseSegment(x, dict));\n          });\n      } else if (!isOptional(n) || dict[name]) {\n        result.searchParams.set(name, reverseSegment(regex, dict));\n      }\n    });\n    result.hash = reverseSegment(decodeURIComponent(target.hash), dict);\n    return `${result}`.replace('ftp://x', '');\n  };\n}\n\nfunction getRouteData(route) {\n  if (!route) {\n    return null;\n  }\n  return { name: route.route.name, params: route.params };\n}\n\nfunction buildEvent({ last, next, type }) {\n  return {\n    last: getRouteData(last),\n    next: getRouteData(next),\n    type,\n  };\n}\n\nfunction paramsToStrings(dict) {\n  for (const key in dict) {\n    if (dict.hasOwnProperty(key)) {\n      if (Array.isArray(dict[key])) {\n        for (let i = 0; i < dict[key].length; i++) {\n          dict[key][i] = dict[key][i].toString();\n        }\n      } else {\n        dict[key] = dict[key] ? dict[key].toString() : null;\n      }\n    }\n  }\n  return dict;\n}\n\nfunction createRouter(base, initialRoutes, emitter = createEventEmitter()) {\n  const trimmedBase = trimSlashes(base);\n  const routes = {};\n  [['root', '/'], ['notFound', '/404'], ...Object.entries(initialRoutes)].forEach(([name, path]) =>\n    register(name, path),\n  );\n  let currentRoute = getMatchingRoute(window.location.href);\n  navigate(currentRoute.route.name, currentRoute.params);\n  window.addEventListener('popstate', refreshCurrentRoute);\n  return {\n    back,\n    destroy,\n    ...emitter,\n    forward,\n    getCurrentRoute,\n    go,\n    navigate,\n    register,\n    replace,\n  };\n  function destroy() {\n    window.removeEventListener('popstate', refreshCurrentRoute);\n  }\n  function createRoute(name, path) {\n    return {\n      decodeURL: parse(path),\n      encodeURL: reverse(path),\n      name,\n    };\n  }\n  function getCurrentRoute() {\n    return getRouteData(currentRoute);\n  }\n  function getMatchingRoute(url) {\n    let params = null;\n    const route = Object.values(routes).find((route) => {\n      params = route.decodeURL(url);\n      return params !== null;\n    });\n    if (!route) {\n      return {\n        params: null,\n        route: routes.notFound,\n      };\n    }\n    return {\n      params,\n      route,\n    };\n  }\n  function refreshCurrentRoute() {\n    const lastRoute = currentRoute;\n    currentRoute = getMatchingRoute(window.location.href);\n    emitter.emit(\n      Router.Events.Transition,\n      buildEvent({\n        last: lastRoute,\n        next: currentRoute,\n        type: Router.Events.Transition,\n      }),\n    );\n  }\n  function go(num) {\n    window.history.go(num);\n  }\n  function back() {\n    window.history.go(-1);\n  }\n  function forward() {\n    window.history.go(1);\n  }\n  function navigate(name, params = {}) {\n    const route = routes[name];\n    if (!route) {\n      return transition(routes['404']);\n    }\n    transition(route, params);\n  }\n  function register(name, path) {\n    if (typeof path === 'undefined' || typeof name === 'undefined') {\n      return null;\n    }\n    routes[name] = createRoute(name, `${trimmedBase}${path}`);\n    return true;\n  }\n  function replace(name, params = {}) {\n    const route = routes[name];\n    if (!route) {\n      return transition(routes['404']);\n    }\n    transition(route, params, true);\n  }\n  function transition(route, params = {}, replace = false) {\n    let url;\n    try {\n      url = route.encodeURL(paramsToStrings(params));\n    } catch (e) {\n      return transition(routes.notFound);\n    }\n    if (!url) {\n      return transition(routes.notFound);\n    }\n    const fullURL = `${window.location.origin}${url}`;\n    if (fullURL === window.location.href) {\n      return;\n    }\n    const lastRoute = currentRoute;\n    currentRoute = { params, route };\n    if (replace) {\n      window.history.replaceState({ name: route.name, params }, '', fullURL);\n    } else {\n      window.history.pushState({ name: route.name, params }, '', fullURL);\n    }\n    emitter.emit(\n      Router.Events.Transition,\n      buildEvent({\n        last: lastRoute,\n        next: currentRoute,\n        type: Router.Events.Transition,\n      }),\n    );\n  }\n}\n\nexport { Router, createRouter };\n//# sourceMappingURL=router.mjs.map\n","var types = /*#__PURE__*/ Object.freeze({\n  __proto__: null,\n});\n\nfunction allDependenciesExist(services, dependencies) {\n  const servicesKeys = Object.keys(services);\n  return dependencies.every((dependency) => servicesKeys.includes(dependency));\n}\n\nfunction byDependency(a, b) {\n  const [aKey, aService] = a;\n  const [bKey, bService] = b;\n  if (typeof aService === 'function') {\n    return -1;\n  }\n  if (typeof bService === 'function') {\n    return 1;\n  }\n  if (aService.includes(bKey)) {\n    return 1;\n  }\n  if (bService.includes(aKey)) {\n    return -1;\n  }\n  return 0;\n}\n\nfunction getDependents(name, services) {\n  return Object.values(services)\n    .filter((service) => service.dependencies.includes(name))\n    .map((service) => service.name);\n}\n\nfunction createContainer(initialServices) {\n  const services = {};\n  if (initialServices) {\n    Object.entries(initialServices)\n      .sort(byDependency)\n      .forEach(([key, service]) => {\n        add(key, service);\n      });\n  }\n  return {\n    add,\n    get,\n    getSingleton,\n    remove,\n    services,\n  };\n  function add(name, constructor) {\n    if (services[name]) {\n      return false;\n    }\n    const order = Object.keys(services).length;\n    if (typeof constructor === 'function') {\n      services[name] = {\n        constructor,\n        dependencies: [],\n        name,\n        order,\n      };\n    } else {\n      const [constructorFn, ...dependencies] = constructor;\n      if (!allDependenciesExist(services, dependencies)) {\n        return false;\n      }\n      services[name] = {\n        constructor: constructorFn,\n        dependencies,\n        name,\n        order,\n      };\n    }\n    return true;\n  }\n  function get(name) {\n    if (!services[name]) {\n      return;\n    }\n    if (!services[name].instance) {\n      instantiate(name);\n    }\n    return services[name].instance;\n  }\n  function getSingleton(name) {\n    if (!services[name]) {\n      return;\n    }\n    return instantiate(name, true);\n  }\n  function instantiate(name, singleton = false) {\n    if (services[name] && services[name].instance && !singleton) {\n      return services[name].instance;\n    }\n    const dependencies = services[name].dependencies\n      ? services[name].dependencies.map((dependency) => instantiate(dependency))\n      : [];\n    const instance = services[name].constructor(...dependencies);\n    if (!singleton) {\n      services[name].instance = instance;\n    }\n    return instance;\n  }\n  function remove(name) {\n    if (getDependents(name, services).length) {\n      return null;\n    }\n    delete services[name];\n    return true;\n  }\n}\n\nexport { types as Container, createContainer };\n//# sourceMappingURL=di.mjs.map\n"],"names":[],"mappings":"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"}