{"version":3,"file":"state.js","sources":["../../utils/dist/utils.mjs"],"sourcesContent":["function createEventEmitter() {\n  const listeners = [];\n  return {\n    addListener,\n    emit,\n    removeListener,\n  };\n  function addListener(type, handler) {\n    const listener = { handler, type };\n    listeners.push(listener);\n  }\n  function emit(type, data) {\n    let listener;\n    const promises = [];\n    for (listener of listeners) {\n      if (listener.type !== type) {\n        continue;\n      }\n      const result = listener.handler(data);\n      if (result === null || result === void 0 ? void 0 : result.then) {\n        promises.push(result);\n      }\n    }\n    return Promise.all(promises);\n  }\n  function removeListener(type, handler) {\n    const ndx = listeners.findIndex((l) => type === l.type && handler === l.handler);\n    if (ndx !== -1) {\n      listeners.splice(ndx, 1);\n    }\n  }\n}\n\nfunction createAsyncQueue() {\n  const entries = [];\n  let flushing = false;\n  return {\n    add,\n    clear,\n    flush,\n  };\n  function add(fn, ...params) {\n    let rej = () => {};\n    let res = () => {};\n    const promise = new Promise((resolve, reject) => {\n      res = resolve;\n      rej = reject;\n    });\n    entries.push({\n      fn,\n      params,\n      reject: rej,\n      resolve: res,\n    });\n    return promise;\n  }\n  function clear() {\n    flushing = false;\n    entries.length = 0;\n  }\n  async function flush() {\n    if (flushing) {\n      return;\n    }\n    const entry = entries[0];\n    if (!entry) {\n      return;\n    }\n    flushing = true;\n    try {\n      const result = await entry.fn(...entry.params);\n      entry.resolve(result);\n      entries.shift();\n      flushing = false;\n      return flush();\n    } catch (e) {\n      entry.reject(e);\n    }\n  }\n}\n\nfunction createSyncQueue() {\n  const entries = [];\n  let flushing = false;\n  return {\n    add,\n    flush,\n  };\n  function add(fn, ...params) {\n    entries.push({\n      fn,\n      params,\n    });\n  }\n  function flush() {\n    if (flushing) {\n      return;\n    }\n    const entry = entries.shift();\n    if (!entry) {\n      flushing = false;\n      return;\n    }\n    flushing = true;\n    entry.fn(...entry.params);\n    if (entries.length) {\n      return flush();\n    }\n  }\n}\n\nexport { createAsyncQueue, createEventEmitter, createSyncQueue };\n//# sourceMappingURL=utils.mjs.map\n"],"names":[],"mappings":";;;;;;;;;;;EAiFA,SAAS,eAAe,GAAG;EAC3B,EAAE,MAAM,OAAO,GAAG,EAAE,CAAC;EACrB,EAAE,IAAI,QAAQ,GAAG,KAAK,CAAC;EACvB,EAAE,OAAO;EACT,IAAI,GAAG;EACP,IAAI,KAAK;EACT,GAAG,CAAC;EACJ,EAAE,SAAS,GAAG,CAAC,EAAE,EAAE,GAAG,MAAM,EAAE;EAC9B,IAAI,OAAO,CAAC,IAAI,CAAC;EACjB,MAAM,EAAE;EACR,MAAM,MAAM;EACZ,KAAK,CAAC,CAAC;EACP,GAAG;EACH,EAAE,SAAS,KAAK,GAAG;EACnB,IAAI,IAAI,QAAQ,EAAE;EAClB,MAAM,OAAO;EACb,KAAK;EACL,IAAI,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,EAAE,CAAC;EAClC,IAAI,IAAI,CAAC,KAAK,EAAE;EAChB,MAAM,QAAQ,GAAG,KAAK,CAAC;EACvB,MAAM,OAAO;EACb,KAAK;EACL,IAAI,QAAQ,GAAG,IAAI,CAAC;EACpB,IAAI,KAAK,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;EAC9B,IAAI,IAAI,OAAO,CAAC,MAAM,EAAE;EACxB,MAAM,OAAO,KAAK,EAAE,CAAC;EACrB,KAAK;EACL,GAAG;EACH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}