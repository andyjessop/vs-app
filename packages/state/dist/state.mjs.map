{"version":3,"file":"state.mjs","sources":["../../utils/dist/utils.mjs"],"sourcesContent":["function createEventEmitter() {\n  const listeners = [];\n  return {\n    addListener,\n    emit,\n    removeListener,\n  };\n  function addListener(type, handler) {\n    const listener = { handler, type };\n    listeners.push(listener);\n  }\n  function emit(type, data) {\n    let listener;\n    for (listener of listeners) {\n      if (listener.type !== type) {\n        continue;\n      }\n      listener.handler(data);\n    }\n  }\n  function removeListener(type, handler) {\n    const ndx = listeners.findIndex((l) => type === l.type && handler === l.handler);\n    if (ndx !== -1) {\n      listeners.splice(ndx, 1);\n    }\n  }\n}\n\nfunction createAsyncQueue() {\n  const entries = [];\n  let flushing = false;\n  return {\n    add,\n    clear,\n    flush,\n  };\n  function add(fn, ...params) {\n    let rej = () => {};\n    let res = () => {};\n    const promise = new Promise((resolve, reject) => {\n      res = resolve;\n      rej = reject;\n    });\n    entries.push({\n      fn,\n      params,\n      reject: rej,\n      resolve: res,\n    });\n    return promise;\n  }\n  function clear() {\n    flushing = false;\n    entries.length = 0;\n  }\n  async function flush() {\n    if (flushing) {\n      return;\n    }\n    const entry = entries[0];\n    if (!entry) {\n      flushing = false;\n      return;\n    }\n    flushing = true;\n    try {\n      const result = await entry.fn(...entry.params);\n      entry.resolve(result);\n      entries.shift();\n      if (entries.length === 0) {\n        flushing = false;\n      }\n      return flush();\n    } catch (e) {\n      entry.reject(e);\n    }\n  }\n}\n\nfunction createSyncQueue() {\n  const entries = [];\n  let flushing = false;\n  return {\n    add,\n    flush,\n  };\n  function add(fn, ...params) {\n    entries.push({\n      fn,\n      params,\n    });\n  }\n  function flush() {\n    if (flushing) {\n      return;\n    }\n    const entry = entries.shift();\n    if (!entry) {\n      flushing = false;\n      return;\n    }\n    flushing = true;\n    entry.fn(...entry.params);\n    if (entries.length) {\n      return flush();\n    }\n  }\n}\n\nexport { createAsyncQueue, createEventEmitter, createSyncQueue };\n//# sourceMappingURL=utils.mjs.map\n"],"names":[],"mappings":"AA+EA,SAAS,eAAe,GAAG;AAC3B,EAAE,MAAM,OAAO,GAAG,EAAE,CAAC;AACrB,EAAE,IAAI,QAAQ,GAAG,KAAK,CAAC;AACvB,EAAE,OAAO;AACT,IAAI,GAAG;AACP,IAAI,KAAK;AACT,GAAG,CAAC;AACJ,EAAE,SAAS,GAAG,CAAC,EAAE,EAAE,GAAG,MAAM,EAAE;AAC9B,IAAI,OAAO,CAAC,IAAI,CAAC;AACjB,MAAM,EAAE;AACR,MAAM,MAAM;AACZ,KAAK,CAAC,CAAC;AACP,GAAG;AACH,EAAE,SAAS,KAAK,GAAG;AACnB,IAAI,IAAI,QAAQ,EAAE;AAClB,MAAM,OAAO;AACb,KAAK;AACL,IAAI,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,EAAE,CAAC;AAClC,IAAI,IAAI,CAAC,KAAK,EAAE;AAChB,MAAM,QAAQ,GAAG,KAAK,CAAC;AACvB,MAAM,OAAO;AACb,KAAK;AACL,IAAI,QAAQ,GAAG,IAAI,CAAC;AACpB,IAAI,KAAK,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;AAC9B,IAAI,IAAI,OAAO,CAAC,MAAM,EAAE;AACxB,MAAM,OAAO,KAAK,EAAE,CAAC;AACrB,KAAK;AACL,GAAG;AACH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}